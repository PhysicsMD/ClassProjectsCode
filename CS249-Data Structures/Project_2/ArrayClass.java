package p3_package;

public class ArrayClass
{
   private int arrayCapacity;
   private int arraySize;
   private static int DEFAULT_CAPACITY = 10;
   static int FAILED_ACCESS = -999999;
   private int[] localArray;
   private int iterator;
   
   /**
    * ArrayClass() Takes no parameters and sets an array size and capacity to 
    * the default of 10
    * It returns nothing
    * */
   public ArrayClass() 
   {
      localArray = new int[DEFAULT_CAPACITY];
      arrayCapacity = DEFAULT_CAPACITY;
      arraySize = 0;
   }
   
   /**
    * ArrayClass(int capacity) takes in capacity and sets it as the size of the 
    * local array and sets it as the array capacity
    * @param capacity This is a users desired size of the arrays capacity
    * */
   public ArrayClass(int capacity) 
   {
      localArray = new int[capacity];
      arrayCapacity = capacity;
   }
   
   /**
    * ArrayClass(int capacity, int size, int fillValue) Takes the users input 
    * and sets size and capacity and fills the array to size with a value
    * @param capacity This is the user defined capacity
    * @param size This is the user defined size
    * @param fillvalue is the value that the user wants to fill the array with
    * */
   public ArrayClass(int capacity, int size, int fillValue) 
   {
      localArray = new int[capacity];
      arrayCapacity = capacity;
      arraySize = size;
      for (iterator = size; iterator > 0; iterator--) 
      {
         localArray[iterator] = fillValue;
      }
   }
   
   /**
    * ArrayClass(ArrayClass copied) Takes another ArrayClass Object and 
    * duplicates it
    * @param copied This is another ArrayClass Object that we will copy into 
    * the current Object
    * */
   public ArrayClass(ArrayClass copied) 
   {
      arraySize = copied.arraySize;
      arrayCapacity = copied.arraySize;
      localArray = copied.localArray;
   }
   
   /**
    * accessItemAt(int accessIndex) is a method that returns the item at an 
    * index
    * @param accessIndex is an integer that is an index of the list the user 
    * wishes for data from
    * @return localArray[accessIndex] if accessIndex is between 0 - arraysize
    * @return FAILED_ACCESS if input invalid/fails
    * */
   public int accessItemAt(int accessIndex) 
   {
      if ((0 < accessIndex)||(accessIndex < this.arraySize)) 
      {
         return this.localArray[accessIndex];
      } 
      else 
      {
         return FAILED_ACCESS;
      }
   }
   
   /**
    * appendItem(int newValue) adds in an new value at the end of the array
    * @param newValue is a number we want to add in the list
    * @return true if it works
    * @return false if it fails
    * */
   public boolean appendItem(int newValue) 
   {
      if (this.arraySize == this.arrayCapacity) 
      {
         return false;
      } 
      else 
      {
         this.arraySize += 1;
         this.localArray[this.arraySize] = newValue;
         return true;
      }
   }
   
   /**
    * clear() sets size to 0 disreguarding the rest of the array with no input 
    * or output
    * */
   public void clear() 
   {
      this.arraySize = 0;
   }
   
   /**
    * dump() prints out the entire contents of the array
    */
   @SuppressWarnings("unused")
   private void dump() 
   {
      iterator = 0;
      System.out.print('[');
      while(iterator<arraySize) 
      {
         System.out.print(localArray[iterator]+',');
         iterator += 1;
      }
      System.out.print(localArray[iterator]+']');
   }
   
   /**
    * getCurrentCapacity() returns the array capacity
    * @return arrayCapacuty give the user the capacity of the array
    * */
   public int getCurrentCapacity() 
   {
      return this.arrayCapacity;
   }
   
   /**
    * getCurrentSize() gives the user the size of the array
    * @return arraysize the size of the array
    * */
   public int getCurrentSize() 
   {
      return this.arraySize;
   }
   
   /** 
    * Generates random number between given low and high values
    * 
    * @param low lowest value that will be generated by method
    * 
    * @param high highest value that will be generated by method
    * 
    * @return the generated random value
    */
   public int getRandBetween( int low, int high )
   {
       int value, range = high-low+1;
       value = (int)(Math.random()*range);
       return low+value;
   }
   
   /**
    * insertItemAt(int insertIndex, int newValue) inputs a value at an index 
    * and shifts all the information down increasing the size if in capacity
    * @param insertIndex is an integer that addresses an index of the array
    * @param newValue is the integer put in the index specified
    * @return true if it worked
    * @return false if input invalid
    * */
   public boolean insertItemAt(int insertIndex, int newValue) 
   {
      if ((insertIndex > this.arraySize)||(insertIndex < 0)) 
      {
         return false;
      } 
      else 
      {
         for (iterator = insertIndex; iterator <= this.arraySize; iterator++) 
         {
            this.localArray[iterator] = this.localArray[iterator + 1];
         }
         this.localArray[insertIndex] = newValue;
         this.arraySize += 1;
         return true;
      }
   }
   
   /**
    * isEmpty() tells if the array is empty
    * @return true if empty
    * @return false if not
    * */
   public boolean isEmpty() 
   {
      if (this.arraySize == 0) 
      {
         return true;
      } 
      else 
      {
         return false;
      }
   }
   
   /**
    * isFull() tells if the array is full
    * @return true if full
    * @return false if not
    * */
   public boolean isFull() 
   {
      if (this.arraySize == this.arrayCapacity) 
      {
         return true;
      } 
      else 
      {
         return false;
      }
   }
   
   /**
    * isInArray(int testVal) tests if a value is in the array
    * @param testVal is the value we wanna test if it is in the array
    * @return true if it worked
    * @return false if input invalid
    * */
   public boolean isInArray(int testVal) 
   {
      boolean test = false;
      iterator = 0;
      while(iterator<=arraySize) 
      {
         if(testVal == localArray[iterator]) 
         {
            test = true;
         }
         iterator+=1;
      }
      return test;
   }
   
   /**
    * loadUniqueRandoms(int numRands, int lowLimit, int highLimit) resets an 
    * array with random values within an range
    * @param numRands is the number of numbers to put in array
    * @param lowLimit is the minimum value for the random number
    * @param highLimit is the maximum value for the random number
    * @return true if it worked
    * @return false if input invalid
    * */
   public boolean loadUniqueRandoms(int numRands, int lowLimit, int highLimit) 
   {
      if(arrayCapacity<numRands) 
      {
         this.resize(numRands);
      }
      this.arraySize = numRands;
      if(highLimit-lowLimit>numRands) 
      {
         return false;
      }
      else 
      {
         iterator = 0;
         while(numRands>0) 
         {
            numRands-=1;
            this.localArray[iterator] = (int)(((highLimit-lowLimit) * 
                  Math.random())+lowLimit);
            iterator+=1;
         }
         return true;
      }
   }
   
   /**
    * removeItemAt(int removeIndex) removes a value at an index and decrements 
    * the size
    * @param removeIndex is an integer that defines a valid index
    * @return removed the value of the removed value
    * @return FAILED_ACCESS if not a valid Index
    * */
   public int removeItemAt(int removeIndex) 
   {
      int removed;
      if ((removeIndex > this.arraySize)||(removeIndex < 0)) 
      {
         return FAILED_ACCESS;
      } 
      else 
      {
         removed = this.localArray[removeIndex];
         for (iterator = removeIndex; iterator <= this.arraySize; iterator++) 
         {
            this.localArray[iterator] = this.localArray[iterator + 1];
         }
         this.arraySize -= 1;
         return removed;
      }
   }
   
   /**
    * resize(int newCapacity) resizes the local array and copies the values in 
    * the size of the array while not allowing it to decrease in capacity
    * @param newCapacity is the integer size of new size
    * @return true if resize worked
    * @return false if resize not valid
    * */
   public boolean resize(int newCapacity) 
   {
      if ((this.arrayCapacity >= newCapacity)||(newCapacity < 0)) 
      {
         return false;
      } 
      else 
      {
         this.arrayCapacity = newCapacity;
         int[] newArray = new int[this.arrayCapacity];
         for (iterator = 0; iterator <= this.arraySize; iterator++) 
         {
            newArray[iterator] = this.localArray[iterator];
         }
         this.localArray = newArray;
         return true;

      }
   }
   
   /**
    * runMerge(int lowIndex, int middleIndex, int highIndex) merges the two 
    * portions of an array in a sorted manner
    * @param lowIndex is the lower index of the targeted portion of array
    * @param middleIndex is the middle index of the targeted portion of array
    * @param highIndex is the upper index of the targeted portion of array
    * */
   private void runMerge(int lowIndex, int middleIndex, int highIndex) 
   {
      int tempsize = highIndex-lowIndex;
      int[] tempArray = new int[tempsize];
      for(iterator = 0; iterator+lowIndex<=highIndex; iterator++) 
      {
         if(lowIndex==highIndex-tempsize/2) 
         {
            tempArray[iterator] = localArray[middleIndex];
            middleIndex++;
         }
         else if(middleIndex==highIndex+1) 
         {
            tempArray[iterator]=localArray[lowIndex];
            lowIndex++;
         }
         else if(localArray[lowIndex]>localArray[middleIndex])
         {
            tempArray[iterator] = localArray[middleIndex];
            middleIndex++;
         }
         else 
         {
            tempArray[iterator] = localArray[lowIndex];
            lowIndex++;
         }
      }
      lowIndex = highIndex-tempsize;
      for(iterator = 0; iterator<tempsize;iterator++) 
      {
         localArray[lowIndex+iterator] = tempArray[iterator];
      }
      
   }
   
   /**
    * runMergeSort() calls the array to be sorted
    * */
   public void runMergeSort() 
   {
      runMergeSortHelper(0,arraySize-1);
   }
   
   /**
    * runMergeSortHelper(int lowIndex, int highIndex) calls portions of the 
    * array to be sorted in a merge
    * @param lowIndex is the lower index of the targeted portion of array
    * @param highIndex is the upper index of the targeted portion of array
    * */
   private void runMergeSortHelper(int lowIndex, int highIndex) 
   {
      int range;
      for(range=2;range<=arraySize; range*=2) 
      {
         for(iterator=0; iterator*range<highIndex; iterator++) 
         {
            int lowend = range*iterator;
            int highend = range*(iterator+1);
            runMerge(lowend, (lowend+highend)/2 ,highend);
         }
      }
   }
   
   /**
    * runPartition(int lowIndex, int highIndex) returns the index of the pivot
    * @param lowIndex is the lower index of the targeted portion of array
    * @param highIndex is the upper index of the targeted portion of array
    * @return pivotindex is the value of the index for the pivot
    * */
   private int runPartition(int lowIndex, int highIndex) 
   {
      int pivot = localArray[highIndex];  
      iterator = (lowIndex-1);
      int iterator2;
      for ( iterator2=lowIndex; iterator2<highIndex;  iterator2++) 
      { 
          if (localArray[iterator2] < pivot) 
          { 
              iterator++;
              int temp = localArray[iterator]; 
              localArray[iterator] = localArray[iterator2]; 
              localArray[iterator2] = temp; 
          } 
      } 
      int temp = localArray[iterator+1]; 
      localArray[iterator+1] = localArray[highIndex]; 
      localArray[highIndex] = temp; 
      int pivotindex = iterator+1;
      return pivotindex;
   }
   
   /**
    * runQuickSort() calls the array to be quick sorted
    * */
   public void runQuickSort() 
   {
      runQuickSortHelper(0, arraySize-1);
   }
   
   /**
    * runQuickSortHelper(int lowIndex, int highIndex) calls the partition of 
    * the sections of the array to be sorted
    * @param lowIndex is the lower index of the targeted portion of array
    * @param highIndex is the upper index of the targeted portion of array
    * */
   private void runQuickSortHelper(int lowIndex, int highIndex) 
   {
      if (lowIndex < highIndex) 
      { 
          int pi = runPartition(lowIndex, highIndex); 
          runQuickSortHelper(lowIndex, pi-1); 
          runQuickSortHelper(pi+1, highIndex); 
      } 
   }
   
   /**
    * Uses Shell's sorting algorithm to sort an array of integers
    * <p>
    * Shell's sorting algorithm is an optimized insertion algorithm
    * 
    * <p>
    * Note: Creates new StudentClass array, sorts contents of array, 
    * and returns the sorted result; 
    * does not modify (this) object student array
    * 
    * @return new StudentClass array with sorted items
    */
   public void runShellSort() 
   {
      int gap, gapPassIndex, insertionIndex;
      int tempItem, testItem;
      boolean continueSearch;
   
      for( gap = arraySize / 2; gap > 0; gap /= 2 )
         {
          for( gapPassIndex = gap; 
                                 gapPassIndex < arraySize; gapPassIndex++ )
             {
              tempItem = localArray[gapPassIndex];

              insertionIndex = gapPassIndex;

              continueSearch = true;
              
              while( continueSearch && insertionIndex >= gap )
                 {
                  testItem = localArray[ insertionIndex - gap ];
                  
                  if( testItem>tempItem )
                     {
                      localArray[ insertionIndex ] 
                                      = localArray[ insertionIndex - gap ];  
                   
                      insertionIndex -= gap;
                     }
                 
                  else
                     {
                      continueSearch = false;
                     }
                  
                 }  // end search loop

              localArray[ insertionIndex ] = tempItem;
             }  // end list loop
      
         }  // end gap size setting loop
   }
   
   /**
    * swaps values in the object array by taking in the indices
    * of the array locations
    * <p>
    * Note: for a small level of optimization, this method does
    * not swap values if the indices are the same
    * 
    * @param oneIndex index of the of the values to be swapped
    * 
    * @param otherIndex index of the other value to be swapped
    */
   @SuppressWarnings("unused")
   private void swapValuesAtIndex( int oneIndex, int otherIndex )
   {
       int temp = localArray[oneIndex];
       if(oneIndex != otherIndex)
       {
           localArray[oneIndex] = localArray[otherIndex];
           localArray[otherIndex] = temp;
       }
   }
}
